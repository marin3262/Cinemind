# CineMind AI 추천 시스템 아키텍처 및 작동 원리

## 1. 시스템 개요

CineMind의 AI 추천 시스템은 **하이브리드(Hybrid) 모델**을 채택하여, 단일 알고리즘의 단점을 보완하고 사용자에게 더 정확하고 풍부한 영화를 추천하도록 설계되었습니다.

핵심적으로 **협업 필터링(Collaborative Filtering)**과 **콘텐츠 기반 필터링(Content-Based Filtering)**이라는 두 가지 주요 방법론을 가중치를 두어 결합하며, 신규 사용자나 데이터가 부족한 상황을 위한 정교한 **대체(Fallback) 로직**을 포함하고 있습니다.

## 2. 핵심 기술 스택

-   **언어:** Python
-   **주요 라이브러리:**
    -   `Pandas`: 데이터 분석 및 가공 (사용자 평점, 영화 정보 등)
    -   `Scikit-learn`: 머신러닝 라이브러리
        -   `TfidfVectorizer`: 영화의 텍스트 정보(장르, 감독, 줄거리 등)를 컴퓨터가 이해할 수 있는 숫자 벡터로 변환합니다.
        -   `cosine_similarity`: 영화 벡터 간의 유사도를 계산하여, 두 영화가 얼마나 비슷한지를 0과 1 사이의 점수로 나타냅니다.
-   **데이터베이스:** Supabase (PostgreSQL) - 영화 정보, 사용자 평점, 학습된 모델(캐시) 저장

## 3. 추천 시스템의 두 단계

CineMind의 추천 시스템은 크게 **1) 오프라인 학습**과 **2) 실시간 추천**이라는 두 단계로 나뉩니다.

### 3.1. 1단계: 모델 학습 (오프라인)

이 단계는 사용자에게 추천을 제공하기 전에 미리 실행되며, 두 종류의 "영화 유사도 모델"을 만들어 데이터베이스에 저장합니다.

#### 모델 A: 협업 필터링 모델 (사용자 패턴 기반)

-   **목표:** "어떤 영화를 좋아한 사용자들이 다른 어떤 영화를 좋아했는가?"라는 패턴을 학습합니다.
-   **작동 순서:**
    1.  **데이터 수집:** DB에서 모든 사용자의 평점(`user_id`, `movie_id`, `rating`) 데이터를 가져옵니다.
    2.  **사용자-아이템 행렬 생성:** 사용자를 행, 영화를 열, 값을 평점으로 하는 거대한 표(Matrix)를 만듭니다.
    3.  **영화 유사도 계산:** 이 표를 기반으로 `코사인 유사도(Cosine Similarity)`를 계산하여, 모든 영화 쌍(A, B)에 대해 "평점 패턴이 얼마나 유사한지"를 점수화합니다.
    4.  **Top-K 최적화 및 저장:** 각 영화마다 가장 패턴이 유사한 **상위 50개**의 영화 목록만 추출하여, `movie_top_k_similarities` 라는 이름으로 DB 캐시에 저장합니다.

#### 모델 B: 콘텐츠 기반 필터링 모델 (영화 내용 기반)

-   **목표:** 영화의 내용(장르, 감독, 배우, 줄거리 등)이 얼마나 비슷한지를 학습합니다.
-   **작동 순서:**
    1.  **데이터 수집:** DB에서 모든 영화의 메타데이터(장르, 감독, 배우, 키워드, 감성 태그 등)를 가져옵니다.
    2.  **특징(Feature) 결합:** 각 영화의 모든 텍스트 정보를 하나의 긴 "소개글"처럼 결합합니다.
    3.  **텍스트 벡터화 (TF-IDF):** `TfidfVectorizer`를 사용하여 이 "소개글"들을 컴퓨터가 분석할 수 있는 숫자 벡터(Vector)의 집합(Matrix)으로 변환합니다. 이 과정에서 각 단어의 중요도가 계산됩니다.
    4.  **콘텐츠 유사도 계산:** 이 벡터 행렬에 `코사인 유사도`를 적용하여, 모든 영화 쌍(A, B)에 대해 "콘텐츠가 얼마나 유사한지"를 점수화합니다.
    5.  **Top-K 최적화 및 저장:** 각 영화마다 콘텐츠가 가장 유사한 **상위 50개**의 영화 목록만 추출하여, `content_similar_top_k` 라는 이름으로 DB 캐시에 저장합니다.

### 3.2. 2단계: 개인화 추천 (실시간 API 호출)

사용자가 앱에서 추천 탭을 열 때, 백엔드에서 실시간으로 다음 과정이 실행됩니다.

1.  **사전 학습 모델 로드:** 1단계에서 만들어 둔 두 종류의 Top-K 유사도 모델(협업, 콘텐츠)을 DB 캐시에서 불러옵니다.
2.  **사용자 정보 확인:**
    -   현재 로그인한 사용자가 **높게 평가한(4점 이상) 영화 목록**을 가져옵니다.
    -   사용자가 이미 본 영화 목록도 확인합니다.

3.  **하이브리드 점수 계산 (핵심 로직):**
    -   추천 후보 영화들의 점수를 기록할 점수판(`Counter`)을 준비합니다.
    -   사용자가 **높게 평가한 각 영화(A)**에 대해,
        -   **협업 필터링 모델**에서 A와 유사한 영화들을 찾아 그 유사도 점수에 **가중치 0.7**을 곱해 점수판에 더합니다.
        -   **콘텐츠 기반 모델**에서 A와 유사한 영화들을 찾아 그 유사도 점수에 **가중치 0.3**을 곱해 점수판에 더합니다.
        -   (사용자가 매긴 평점이 높을수록(예: 5점 > 4점) 점수에 더 큰 영향을 줍니다.)
    -   이 과정을 모든 '높게 평가한 영화'에 대해 반복하면, 점수판에는 여러 이유로 추천된 영화들의 점수가 누적됩니다.

4.  **최종 목록 생성:**
    -   점수판의 모든 영화 중에서, **사용자가 이미 본 영화는 제외**합니다.
    -   남은 영화들을 최종 누적 점수가 높은 순으로 정렬합니다.
    -   정렬된 목록에서 **상위 20개**의 영화를 최종 추천 목록으로 사용자에게 반환합니다.

## 4. 특별 예외 처리 로직

-   **신규 사용자 (Cold-Start Problem):**
    -   사용자가 앱에 처음 가입하여 평점 기록이 전혀 없을 때는 위와 같은 개인화 추천이 불가능합니다.
    -   이 경우, 회원가입 직전의 **온보딩 단계에서 '좋아요'를 눌렀던 영화**들을 기반으로, **콘텐츠 기반 추천**을 제공하여 초기 추천 경험을 제공합니다.

-   **대체 추천 (Fallback System):**
    -   만약 개인화 추천을 시도했으나 결과가 없는 경우(예: 사용자가 평가한 영화가 너무 적거나, 높은 평점을 준 영화가 없는 경우), 시스템은 추천을 포기하지 않습니다.
    -   대신, 사용자가 그나마 평가했던 영화들의 **장르를 분석**하여, 해당 장르의 **인기 있는 영화들**을 추천해 줍니다.

-   **기분 필터링 (Mood Filtering):**
    -   사용자가 "오늘 기분"을 선택하면, 최종 추천 목록에서 해당 기분과 관련된 `감성 태그`를 가진 영화들만 한 번 더 필터링하여 보여주는 추가 기능이 있습니다.
